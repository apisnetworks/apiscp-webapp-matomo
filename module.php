<?php
	/**
	 *  +------------------------------------------------------------+
	 *  | apnscp                                                     |
	 *  +------------------------------------------------------------+
	 *  | Copyright (c) Apis Networks                                |
	 *  +------------------------------------------------------------+
	 *  | Licensed under Artistic License 2.0                        |
	 *  +------------------------------------------------------------+
	 *  | Author: Matt Saladna (msaladna@apisnetworks.com)           |
	 *  +------------------------------------------------------------+
	 */

	use Module\Support\Webapps;
	use Module\Support\Webapps\App\Type\Matomo\Handler;
	use Module\Support\Webapps\PhpWrapper;
	use Module\Support\Webapps\DatabaseGenerator;
	use Module\Support\Webapps\VersionFetcher\Github;
	use Opcenter\Auth\Password;
	use Opcenter\Map;
	use Opcenter\Provisioning\ConfigurationWriter;
	use Opcenter\SiteConfiguration;
	use Opcenter\Versioning;

	/**
	 * Matomo management
	 *
	 * @package core
	 */
	class Matomo_Module extends Webapps
	{
		const REGISTERED_HANDLER_KEY = 'webapps.tracking.matomo';
		const APP_NAME = Handler::NAME;
		const DEFAULT_VERSION_LOCK = 'minor';

		protected $aclList = array(
			'min' => array(
				'tmp',
				'config/config.ini.php'
			),
			'max' => array(
				'tmp',
				'config/config.ini.php'
			)
		);

		protected const CLEANUP_FILES = [
			'CHANGELOG.md',
			'CONTRIBUTING.md',
			'How to install Matomo.html',
			'LEGALNOTICE',
			'LICENSE',
			'PRIVACY.md',
			'README.md',
			'SECURITY.md'
		];

		/**
		 * Install Laravel into a pre-existing location
		 *
		 * @param string $hostname domain or subdomain to install Laravel
		 * @param string $path     optional path under hostname
		 * @param array  $opts     additional install options
		 * @return bool
		 */
		public function install(string $hostname, string $path = '', array $opts = array()): bool
		{
			if (!$this->mysql_enabled()) {
				return error('%(what)s must be enabled to install %(app)s',
					['what' => 'MySQL', 'app' => static::APP_NAME]);
			}

			if (!version_compare($this->php_version(), '7', '>=')) {
				return error('Matomo requires PHP7');
			}

			if (!($docroot = $this->getDocumentRoot($hostname, $path))) {
				return error("failed to normalize path for `%s'", $hostname);
			}

			if (!$this->parseInstallOptions($opts, $hostname, $path)) {
				return false;
			}

			$args['version'] = $opts['version'];


			$oldex = Error_Reporter::exception_upgrade(Error_Reporter::E_ERROR);
			$approot = $this->getAppRoot($hostname, $path);
			try {
				$this->downloadVersion($approot, $args['version']);

				$db = DatabaseGenerator::mysql($this->getAuthContext(), $hostname);
				$db->connectionLimit = max($db->connectionLimit, 15);
				if (!$db->create()) {
					return false;
				}
				if (!isset($opts['password'])) {
					$opts['password'] = $password = Password::generate();
					info("autogenerated password `%s'", $password);

				}

				$svc = SiteConfiguration::shallow($this->getAuthContext());

				$envcfg = (new ConfigurationWriter('@webapp(matomo)::templates.config',
					$svc))->compile();
				$this->file_put_file_contents("${approot}/config/config.ini.php", (string)$envcfg);
				$this->set_configuration($hostname, $path, [
					'database' => [
						'host'          => $db->hostname,
						'username'      => $db->username,
						'password'      => $db->password,
						'tables_prefix' => '',
						'dbname'        => $db->database
					]
				]);

				$createTableCommand = $approot . '/plugins/CoreAdminHome/Commands/CreateTables.php';
				$this->file_put_file_contents(
					$createTableCommand,
					file_get_contents((new ConfigurationWriter('@webapp(matomo)::templates.create-table-command',
						$svc))->getTemplatePath())
				);
				PhpWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot))->exec($approot,
					'console database:create-tables');
				$this->file_delete($createTableCommand);

				PhpWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot))->exec($approot,
					'console core:update --yes');
			} catch (apnscpException $e) {
				$this->file_delete($approot, true);

				return error('Failed to install %s: %s', static::APP_NAME, $e->getMessage());
			} finally {
				Error_Reporter::exception_upgrade($oldex);
			}

			$this->initializeMeta($docroot, $opts);

			$email = $opts['email'] ?? $this->common_get_email();

			$this->fixRewriteBase($docroot);
			// create admin
			$argSets = [
				[
					'method'    => 'UsersManager.addUser',
					'userLogin' => $opts['user'],
					'password'  => $opts['password'],
					'email'     => $email
				],
				[
					'method'    => 'UsersManager.setSuperUserAccess',
					'userLogin' => $opts['user'],
					'hasSuperUserAccess' => true
				]
			];

			foreach ($argSets as $set) {
				$this->apiCommand($approot, array_pull($set, 'method'), $set);
			}

			$this->track_site($hostname, $path);

			$this->fortify($hostname, $path, Module\Support\Webapps\App\Type\Matomo\Handler::DEFAULT_FORTIFICATION);
			$this->notifyInstalled($hostname, $path, $opts);

			return info('%(app)s installed - confirmation email with login info sent to %(email)s',
				['app' => static::APP_NAME, 'email' => $opts['email']]);
		}

		/**
		 * List all registered Matomo instances
		 *
		 * @return array
		 */
		public function registered(): array
		{
			$cfg = array_get(Preferences::factory($this->getAuthContext()), self::REGISTERED_HANDLER_KEY, []);
			return array_build($cfg, static function ($k, $v) {
				return [$k, $v];
			});

		}

		/**
		 * Register a host spec as a Matomo tracker
		 *
		 * @param string $hostname
		 * @param string $path
		 * @return string|null
		 */
		public function register(string $hostname, string $path = ''): ?string
		{

			if (!$this->valid($hostname, $path)) {
				error("%(hostname)s%(path)s is not a valid %(app)s instance", ['hostname' => $hostname, 'path' => $path, 'app' => self::APP_NAME]);
				return null;
			}

			$path = rtrim($path, '/');
		}

		public function track_site(string $hostname, string $path = '', string $tracker = null): ?string
		{
			$approot = $this->getAppRoot($hostname, $path);
			$ret = $this->apiCommand($approot, 'SitesManager.addSite', "$hostname/$path", "$hostname/$path");
			if (!$ret['success']) {
				return false;
			}
		}

		public function untrack_site(string $hostname, string $path = '', string $tracker = null): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			$ret = $this->apiCommand($approot, 'SitesManager.addSite', "$hostname/$path", "$hostname/$path");
			return false;
		}

		public function tracked(string $hostname, string $path = ''): bool
		{
			return false;
		}

		public function plugin_status(string $hostname, string $path = '', string $plugin = null)
		{
			return parent::plugin_status($hostname, $path, $plugin); // TODO: Change the autogenerated stub
		}

		public function install_plugin(string $hostname, string $path, string $plugin, string $version = ''): bool
		{
			return parent::install_plugin($hostname, $path, $plugin, $version); // TODO: Change the autogenerated stub
		}

		public function uninstall_plugin(string $hostname, string $path, string $plugin, bool $force = false): bool
		{
			return parent::uninstall_plugin($hostname, $path, $plugin, $force); // TODO: Change the autogenerated stub
		}

		/**
		 * Extract remote Matomo version into directory
		 *
		 * @param string $approot
		 * @param string $version
		 * @return bool
		 */
		private function downloadVersion(string $approot, string $version): bool
		{
			if (null === ($meta = $this->versionMeta($version))) {
				return error("Cannot locate %(app)s version %(version)s", [
					'app'     => self::APP_NAME,
					'version' => $version
				]);
			}
			$dlUrl = array_first($meta['assets'], static function ($asset) {
				return substr($asset['name'], -4) === '.zip';
			});
			$dlUrl = $dlUrl['browser_download_url'];

			$this->download($dlUrl, "$approot/");
			foreach (static::CLEANUP_FILES as $file) {
				$this->file_exists("$approot/matomo/$file") && $this->file_delete("$approot/matomo/$file");
			}

			return $this->file_copy("$approot/matomo/", $approot) && $this->file_delete("$approot/matomo", true);
		}

		/**
		 * Apply API command
		 *
		 * @param string $approot
		 * @param array  $params
		 * @return array
		 */
		private function apiCommand(string $approot, string $method, array $params): array {
			$ret = PhpWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot))->exec(
				$approot, 'console climulti:request --superuser %s', [http_build_query($params + ['module' => 'API', 'method' => $method, 'format' => 'json'])]);
			$ret['stdout'] = json_decode($ret['stdout'], true);
			if ($ret['stdout']['result'] === 'error') {
				$ret['success'] = false;
			}
			return $ret;
		}

		/**
		 * Set config.ini configuration
		 * @param string $hostname hostname
		 * @param string $path path
		 * @param array  $params dot or nested params
		 * @return bool|mixed
		 */
		public function set_configuration(string $hostname, string $path, array $params = [])
		{
			if (!IS_CLI) {
				return $this->query('matomo_set_configuration', $hostname, $path, $params);
			}
			if (!$this->valid($hostname, $path)) {
				return error("Not a valid %(app)s installation", static::APP_NAME);
			}
			$config = $this->getAppRoot($hostname, $path) . '/config/config.ini.php';
			$ini = Map::load($this->domain_fs_path($config), 'wd', 'inifile')->section(null);
			clearstatcache(true, $this->domain_fs_path($config));
			if (!str_starts_with(realpath($this->domain_fs_path($config)), $this->domain_fs_path('/'))) {
				$ini->close();
				fatal("Unsafe path");
			}

			foreach (dot($params) as $k => $v) {
				[$section, $option] = explode('.', $k, 2);
				$ini->section($section)->offsetSet($option, $v);
			}

			return $ini->save();
		}

		/**
		 * @param string       $hostname
		 * @param string       $path
		 * @param string|array $fields
		 * @return mixed
		 */
		public function get_configuration(string $hostname, string $path, $fields): array
		{
			if (!IS_CLI) {
				return $this->query('matomo_get_configuration', $hostname, $path, $fields);
			}
			$config = $this->getAppRoot($hostname, $path) . '/config/config.ini.php';
			$fstPath = $this->domain_fs_path($config);
			if (!file_exists($fstPath)) {
				error("`%(file)s' does not exist", ['file' => $config]);
				return [];
			}
			$map = Map::read($fstPath, 'inifile');
			$values = [];
			$fields = (array)$fields;
			if (is_array(current($fields))) {
				$tmp = [];
				foreach ($fields as $k => $items) {
					foreach ($items as $v) {
						$tmp[] = "${k}.${v}";
					}
				}
				$fields = $tmp;
			}

			foreach ($fields as $q) {
				[$section, $option] = explode('.', $q, 2);
				array_set($values, $q, $map->quoted(true)->section($section)[$option] ?? null);
			}

			if (count($fields) === 1) {
				return array_pop($values);
			}

			return $values;
		}

		/**
		 * Release meta
		 *
		 * @param string $version
		 * @return array|null
		 */
		private function versionMeta(string $version): ?array
		{
			return array_first($this->_getVersions(), static function ($meta) use ($version) {
				return $meta['tag_name'] === $version;
			});
		}

		/**
		 * Get installed version
		 *
		 * @param string $hostname
		 * @param string $path
		 * @return string version number
		 */
		public function get_version(string $hostname, string $path = ''): ?string
		{
			$approot = $this->getAppRoot($hostname, $path);

			if (!$this->valid($hostname, $path)) {
				return null;
			}

			$ret = PhpWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot))->exec($approot, 'console core:version');
			if (!$ret['success']) {
				return null;
			}

			return trim($ret['stdout']);
		}

		/**
		 * Location is a valid Matomo install
		 *
		 * @param string $hostname or $docroot
		 * @param string $path
		 * @return bool
		 */
		public function valid(string $hostname, string $path = ''): bool
		{
			if ($hostname[0] === '/') {
				$approot = $hostname;
			} else {
				$approot = $this->getAppRoot($hostname, $path);
				if (!$approot) {
					return false;
				}
			}
			return $this->file_exists($approot . '/core/Piwik.php');
		}

		/**
		 * Get all available Ghost versions
		 *
		 * @return array
		 */
		public function get_versions(): array
		{
			$versions = $this->_getVersions();

			return array_column(array_filter($versions, static function ($meta) {
				return false === strpos($meta['version'], '-');
			}), 'version');
		}

		/**
		 * Get all current major versions
		 *
		 * @return array
		 */
		private function _getVersions(): array
		{
			$key = 'matomo.versions';
			$cache = Cache_Super_Global::spawn();
			if (false !== ($ver = $cache->get($key))) {
				return (array)$ver;
			}
			$versions = (new Github)->fetch('matomo-org/matomo');

			$cache->set($key, $versions, 43200);

			return $versions;
		}

		/**
		 * Get database configuration for a blog
		 *
		 * @param string $hostname domain or subdomain of wp blog
		 * @param string $path     optional path
		 * @return array|bool
		 */
		public function db_config(string $hostname, string $path = '')
		{
			$params = [
				'host'     => 'host',
				'user'     => 'username',
				'prefix'   => 'tables_prefix',
				'db'       => 'dbname',
				'password' => 'password'
			];

			if (!$cfg = $this->get_configuration($hostname, $path, ['database' => array_values($params)])) {
				return error("Failed to retrieve db configuration");
			}

			return array_combine(array_keys($params), $cfg['database']);
		}

		public function update_all(string $hostname, string $path = '', string $version = null): bool
		{
			return $this->update($hostname, $path, $version) || error('failed to update all components');
		}

		/**
		 * Update Laravel to latest version
		 *
		 * @param string $hostname domain or subdomain under which WP is installed
		 * @param string $path     optional subdirectory
		 * @param string $version  version to upgrade
		 * @return bool
		 */
		public function update(string $hostname, string $path = '', string $version = null): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			if (!$approot) {
				return error('update failed');
			}

			$oldversion = $this->get_version($hostname, $path);
			$ret = serial(function () use ($approot, $version, $hostname, $path) {
				if (!$version) {
					$version = Versioning::nextVersion($this->get_versions(),
						$this->get_version($hostname, $path));
				} else if (!Versioning::valid($version)) {
					return error('invalid version number, %s', $version);
				}
				$this->downloadVersion($approot, $version);
				$ret = PhpWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot))->exec($approot,
					'console core:update --yes');
				if (!$ret['success']) {
					return error("Failed to upgrade %s: %s", static::APP_NAME, $ret['stdout']);
				}

				return $this->fortify($hostname, $path, data_get($this->getOptions($approot), 'fortify') ?: 'max');
			});

			$this->setInfo($approot, [
				'version' => $ret ? $version : $oldversion,
				'failed'  => !$ret
			]);

			return (bool)$ret;
		}

		/**
		 * Get the primary admin for a WP instance
		 *
		 * @param string      $hostname
		 * @param null|string $path
		 * @return string admin or false on failure
		 */
		public function get_admin(string $hostname, string $path = ''): ?string
		{
			$docroot = $this->getAppRoot($hostname, $path);
			$ret = $this->apiCommand($docroot, 'UsersManager.getUsers');
			if ($ret['success']) {

				foreach ($ret['stdout'] as $user) {
					if ($user['superuser_access']) {
						return $user['login'];
					}
				}
			}
			warn('failed to enumerate administrative users');

			return null;
		}

		/**
		 * Change admin user
		 *
		 * @param string $hostname
		 * @param string $path
		 * @param array  $fields password, email acceptable values
		 * @return bool
		 */
		public function change_admin(string $hostname, string $path, array $fields): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			if (!$approot) {
				return warn('failed to change administrator information');
			}
			$admin = 'xykbhmbuelbebiga';//$this->get_admin($hostname, $path);

			if (!$admin) {
				return error('cannot determine admin of install');
			}

			if (!empty($fields['password'])) {
				if (!Password::strong($fields['password'], $admin)) {
					return false;
				}
				$dbCfg = $this->db_config($hostname, $path);
				$pdo = Module\Support\Webapps::connectorFromCredentials($dbCfg);
				$crypted = password_hash(md5($fields['password']), PASSWORD_DEFAULT);
				$rc = $pdo->exec("UPDATE " . $dbCfg['prefix'] . "user SET password = " . $pdo->quote($crypted) . " WHERE login = " . $pdo->quote($admin));
				if (!$rc) {
					return error("Failed to update admin user `%s' password", $admin);
				}
			}

			if (empty($fields['email'])) {
				return true;
			}

			$ret = $this->apiCommand($approot, 'UsersManager.updateUser', [
				'userLogin' => $admin,
				'email' => $fields['email']
			]);

			return $ret['success'] ?: error(array_get($ret, 'stdout.message', 'Unspecified error'));
		}
	}